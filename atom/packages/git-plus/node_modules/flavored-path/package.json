{
  "name": "flavored-path",
  "version": "0.0.8",
  "description": "path module revisited with backward compatibility and additional features",
  "keywords": [
    "path",
    "backward",
    "compatibility",
    "flavored"
  ],
  "author": {
    "name": "Gabriel Llamas",
    "email": "gaglekas@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Gagle/Node-FlavoredPath.git"
  },
  "engines": {
    "node": "*"
  },
  "dependencies": {
    "meta-path": "*"
  },
  "devDependencies": {
    "mocha-runner": "*"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://www.opensource.org/licenses/mit-license.html"
    }
  ],
  "main": "lib/flavored-path",
  "readme": "flavored-path\r\n=============\r\n\r\n_Node.js project_\r\n\r\n#### \"path\" module revisited with backward compatibility and additional features ####\r\n\r\nVersion: 0.0.8\r\n\r\nThe goal of this module is to fix the current working directory issue, provide backward compatibility to the `path.normalize()` function (it's terribly bugged on Windows), provide forward compatibility with the `path.sep`, `path.delimiter` aliases and all future aditions and add additional useful methods.\r\n\r\nThis module uses [meta-path](https://github.com/Gagle/Node-MetaPath) to guarantee the backward compatibility. See its documentation to understand the problems and the fixes.\r\n\r\nThe primary intention is to use `flavored-path` as a complete replacement of the `path` built-in module.\r\n\r\nEvery time you call a fs built-in function I recommend to call to the [get()](#get) function:\r\n\r\n```javascript\r\nvar fs = require (\"fs\");\r\nvar path = require (\"flavored-path\");\r\nfs.exists (path.get (\"my/path\"), cb);\r\n```\r\n\r\nThe [get()](#get) function will take care all the possible types of path (relative, absolute, network shared resource and relative from the home directory on Linux) and fix, resolve or whatever they need in order to work as expected.\r\n\r\n#### Installation ####\r\n\r\n```\r\nnpm install flavored-path\r\n```\r\n\r\n#### Example ####\r\n\r\n```javascript\r\nvar fs = require (\"fs\");\r\nvar path = require (\"flavored-path\");\r\n\r\n/*\r\npath.get (\".\") is equivalent to __dirname but get() can be used with any type\r\nof path, e.g.: Linux home paths (~/a/b).\r\n\r\nOn Linux, home paths are resolved to absolute files, so this snippet prints\r\nall the entries in the user's home path.\r\n\r\nOn Windows, home paths are processed like regular relative paths, that is,\r\nget() will return something like this: <cwd>/~/, so don't use ~ on Windows.\r\n\r\nThe Node.js built-in functions work the same way, for them ~ is processed\r\nlike a relative home path.\r\n*/\r\n\r\nfs.readdir (path.get (\"~\"), function (error, files){\r\n\tif (error) return console.log (error);\r\n\tconsole.log (files);\r\n});\r\n```\r\n\r\n#### Methods and Properties ####\r\n\r\n- [path.basename(p[, ext])](#basename)\r\n- [path.delimiter](#delimiter)\r\n- [path.dirname(p)](#dirname)\r\n- [path.extname(p)](#extname)\r\n- [path.get(p)](#get)\r\n- [path.isAbsolute(p)](#isAbsolute)\r\n- [path.isHome(p)](#isHome)\r\n- [path.isNetwork(p)](#isNetwork)\r\n- [path.isRelative(p)](#isRelative)\r\n- [path.isRoot(p)](#isRoot)\r\n- [path.join(path1, path2[, ...])](#join)\r\n- [path.normalize(p)](#normalize)\r\n- [path.prefix(p)](#prefix)\r\n- [path.realpath(p)](#realpath)\r\n- [path.relative(from, to)](#relative)\r\n- [path.removePrefix(p)](#removePrefix)\r\n- [path.resolve([from, [...]], to)](#resolve)\r\n- [path.sep](#sep)\r\n\r\n<a name=\"basename\"></a>\r\n__path.basename(p[, ext])__  \r\nSame Node.js built-in function ([path.basename()](https://github.com/joyent/node/blob/master/doc/api/path.markdown#pathbasenamep-ext)).\r\n\r\n<a name=\"delimiter\"></a>\r\n__path.delimiter__  \r\nSame Node.js built-in function ([path.delimiter](https://github.com/joyent/node/blob/master/doc/api/path.markdown#pathdelimiter)).\r\n\r\n<a name=\"dirname\"></a>\r\n__path.dirname(p)__  \r\nSame Node.js built-in function ([path.dirname()](https://github.com/joyent/node/blob/master/doc/api/path.markdown#pathdirnamep)).\r\n\r\n<a name=\"extname\"></a>\r\n__path.extname(p)__  \r\nSame Node.js built-in function ([path.extname()](https://github.com/joyent/node/blob/master/doc/api/path.markdown#pathextnamep)).\r\n\r\n<a name=\"get\"></a>\r\n__path.get(p)__  \r\nReturns a path suitable for using with a `fs` built-in function. Every time you need to call to a `fs` function you can call to this function:\r\n\r\n```javascript\r\nfs.exists (path.get (\"a\"), cb);\r\n```\r\n\r\nYou can pass any type of path. It will be normalized, fixed, resolved, whatever modification to convert the given path to a valid path for using with any `fs` built-in function.\r\n\r\nThe path is normalized and if the script is executed from a different directory from where the main script it's executed, e.g. `node a/app.js` instead of `node app.js`, the path is also be fixed. Example:\r\n\r\n```javascript\r\n//app.js\r\nvar path = require (\"flavored-path\");\r\nconsole.log (path.get (\"app.js\"));\r\n```\r\n\r\n```\r\n$ pwd\r\n/home/gll\r\n$ node a/app.js\r\na/app.js\r\n```\r\n\r\nIf `flavored-path` it's used within a global module it makes no sense to try to fix a relative path because it's not needed. In this case the function only normalizes the path and returns it.\r\n\r\nIn fact, this function provides the same funcionality as the `__dirname` approach but also works in third-party modules whereas `__dirname` cannot be used in them.\r\n\r\n<a name=\"isAbsolute\"></a>\r\n__path.isAbsolute(p)__  \r\nChecks whether the path is absolute. An absolute path begins with `/` or `\\` (the prefix is skipped, e.g.: `D:`), this means that network paths are also absolute. The given path doesn't need to be normalized. Returns true if is absolute, false otherwise.\r\n\r\n<a name=\"isHome\"></a>\r\n__path.isHome(p)__  \r\nChecks whether the path is relative from the user's home directory. A home path path begins with `~` (cannot contain a prefix), this means that home paths are also relative. The given path doesn't need to be normalized. Returns true if is a home path, false otherwise.\r\n\r\n<a name=\"isNetwork\"></a>\r\n__path.isNetwork(p)__  \r\nChecks whether the path is a network resource (on Windows world this is called a UNC path). A network path begins with `//` or `\\\\\\\\` (the prefix is skipped, e.g.: `smb:`). The given path doesn't need to be normalized. Returns true if is a network resource, false otherwise.\r\n\r\n<a name=\"isRelative\"></a>\r\n__path.isRelative(p)__  \r\nChecks whether the path is relative. A relative path begins with any character different from `/` or `\\` (the prefix is skipped, e.g.: `D:`). The given path doesn't need to be normalized. Returns true if is relative, false otherwise.\r\n\r\n<a name=\"isRoot\"></a>\r\n__path.isRoot(p)__  \r\nChecks whether the path is a root. A root path is equal to `/`, `\\`, `//` or `\\\\` (the prefix is skipped, e.g.: `D:`). The given path doesn't need to be normalized. Returns true if is a root path, false otherwise.\r\n\r\n<a name=\"join\"></a>\r\n__path.join(path1, path2[, ...])__  \r\nSame Node.js built-in function ([path.join()](https://github.com/joyent/node/blob/master/doc/api/path.markdown#pathjoinpath1-path2-)).\r\n\r\nThe joined path is correctly normalized.\r\n\r\n```javascript\r\nconsole.log (path.join (\"smb://a//b\", \"c/\")); //Prints: smb://a/b/c/\r\n```\r\n\r\n<a name=\"normalize\"></a>\r\n__path.normalize(p)__  \r\nSame Node.js built-in function ([path.normalize()](https://github.com/joyent/node/blob/master/doc/api/path.markdown#pathnormalizep)).\r\n\r\nTakes care all of the bugs found in the built-in normalize function explained in the [meta-path](https://github.com/Gagle/Node-MetaPath) module.\r\n\r\n<a name=\"prefix\"></a>\r\n__path.prefix(p)__  \r\nReturns the prefix. The prefix is the string before `:` (included).\r\n\r\n<a name=\"realpath\"></a>\r\n__path.realpath(p)__  \r\nAn alias for the `resolve()` function. The real path of `.` it's the real current working directory with the relative fix applied.\r\n\r\n```javascript\r\n/*\r\nYou can overwrite the built-in cwd function and cache the result.\r\nNow, the process.cwd() function will always return the same path if\r\nyou move across the directories and execute a script from outside of its\r\ndirectory, so you don't need to call to get():\r\n\r\n$ node app.js\r\n$ node dir/app.js\r\n$ node ../app.js\r\n*/\r\n\r\nprocess.cwd = (function (){\r\n\tvar cwd = path.realpath (\".\");\r\n\treturn function (){\r\n\t\treturn cwd;\r\n\t};\r\n})();\r\n```\r\n\r\nThis is an error prone solution because you're overwritting a built-in Node.js function, and you may have other modules that may stop working properly. Use with caution.\r\n\r\n<a name=\"relative\"></a>\r\n__path.relative(from, to)__  \r\nSame Node.js built-in function ([path.relative()](https://github.com/joyent/node/blob/master/doc/api/path.markdown#pathrelativefrom-to)).\r\n\r\n<a name=\"removePrefix\"></a>\r\n__path.removePrefix(p)__  \r\nReturns the path without the prefix.\r\n\r\n<a name=\"resolve\"></a>\r\n__path.resolve([from, [...]], to)__  \r\nSame Node.js built-in function ([path.resolve()](https://github.com/joyent/node/blob/master/doc/api/path.markdown#pathresolvefrom--to)).\r\n\r\nThe absolute path that is returned fixes the current working directory issue.\r\n\r\nThe Linux relative home paths are resolved to its absolute path (only on Linux). The resolve built-in function doesn't provide this functionality. The `fs` built-in functions don't expand `~` to the user's home path, so when you deal with home paths you must convert it first to an absolute path:\r\n\r\n```javascript\r\nfs.exists (path.resolve (\"~/a\"), cb);\r\n//Or simply:\r\n//fs.exists (path.get (\"~/a\"), cb);\r\n```\r\n\r\nNetwork resource paths (paths that begin with `//`) are also resolved correctly.\r\n\r\nSome examples:\r\n\r\n\r\n```javascript\r\n//app.js\r\nconsole.log (path.resolve (\"b\", \"c\")); //Prints: /home/gll/a/b/c\r\nconsole.log (path.resolve (\"s\", \"~/a\")); //Prints: /home/gll/a\r\nconsole.log (path.resolve (\"s\", \"/a\", \"b\")); //Prints: /a/b\r\nconsole.log (path.resolve (\"s\", \"//a\", \"b\")); //Prints: //a/b\r\n```\r\n\r\n```\r\n$ pwd\r\n/home/gll\r\n$ node a/app.js\r\n```\r\n\r\n<a name=\"sep\"></a>\r\n__path.sep__  \r\nSame Node.js built-in property ([path.sep](https://github.com/joyent/node/blob/master/doc/api/path.markdown#pathsep)).",
  "readmeFilename": "README.md",
  "_id": "flavored-path@0.0.8",
  "dist": {
    "shasum": "b379c8afec841afe1dd0d2ecaab11e0cc79d7aca",
    "tarball": "http://registry.npmjs.org/flavored-path/-/flavored-path-0.0.8.tgz"
  },
  "_from": "flavored-path@0.0.8",
  "_npmVersion": "1.2.14",
  "_npmUser": {
    "name": "Gagle",
    "email": "gaglekas@gmail.com"
  },
  "maintainers": [
    {
      "name": "Gagle",
      "email": "gaglekas@gmail.com"
    }
  ],
  "directories": {},
  "deprecated": "use rwd",
  "_shasum": "b379c8afec841afe1dd0d2ecaab11e0cc79d7aca",
  "_resolved": "https://registry.npmjs.org/flavored-path/-/flavored-path-0.0.8.tgz",
  "bugs": {
    "url": "https://github.com/Gagle/Node-FlavoredPath/issues"
  },
  "homepage": "https://github.com/Gagle/Node-FlavoredPath#readme"
}
